# Course Data Scraping

Lions Den is an old system, and without direct access to the database from which it draws its information, our advising app will not be able to easily retrieve the course data.  As such, we'll want to create a bot that gets the relevant course data and stores all of it in a file in a format that's easily usable by our app.  The format we'll be using is called JSON (JavaScript Object Notation).  A bot that does this is called a web scraper.  To do this, we'll need to have it simulate the steps that a person would do: make a course search for all courses and manually retrieve the data for each course one page at a time.  The bot of course will accomplish this task a little differently than we would as it will not be using a mouse and a keyboard to navigate through the results and it will be working with source code rather than the output we see on the screen.  This means we will need to look "under the hood" to see the form data that's being sent and the HTML that's used for displaying the course information to determine how we program the bot.  

## Inspection of Requests and Responses
+ To determine the necessary request data (header and body), open up the Developer console first, make a search for courses at https://lionsden.molloy.edu/ICS/Course_Search/Course_Search.jnz?portlet=Course_Schedules&screen=Advanced+Course+Search&screenType=next and check the Network tab:
![image](https://user-images.githubusercontent.com/9159008/183238756-8840d8a2-812f-4c81-9156-efd5ff2d7110.png)
+ The relevant request is under `Course_Search.jnz?portlet=Course_Schedules&screen=Advanced+Course+Search&screenType=next`.
+ Trial and error by removing and modifying request data can tell you what's essential for it to succeed.  Using a tool such as Burp Suite Proxy allows you to modify and repeat the requests and see the response.  This way you can see those that provide the desired response data, which in this case will be the list of courses.  We'll spare you from this tedious work, and let you know what's needed:
  + **ASP.NET_SessionId Cookie**: When you first visit the site, the response will set this header to some "randomly generated number encoded into a 24-character string" (https://docs.microsoft.com/en-us/dotnet/api/system.web.sessionstate.sessionidmanager?view=netframework-4.8#remarks)
  + **Content-type header describing the format of the form data encoding**: `"content-type" : "multipart/form-data; boundary=----FormBoundary"` (https://stackoverflow.com/questions/3508338/what-is-the-boundary-in-multipart-form-data).
  + **method: "POST"**: This is the request method, which means there will be data in the body that's not part of the URL that's being requested.  The data in this case will be the encoded form data (https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)
  + **Value of hidden `___BrowserRefresh` form field**: There will be a new value each time we request a list of courses in a search or go through the pages in a search.  Using the same value twice gives you the following fun error message:
![image](https://user-images.githubusercontent.com/9159008/183279980-6c36a39d-8bd9-4a6f-a15b-a8d3dde4d4eb.png)
  + **Body data (Payload)**: Includes value of hidden `___BrowserRefresh` form field mentioned above: This will be a long string of names of fields and their values, separated by `----FormBoundary` indicated in the boundary of the `content-type` header and new lines (`\n`).  It'll be one long string that looks like the following (browser refresh key will be replaced with some value):
```
------FormBoundary\nContent-Disposition: form-data; name="__EVENTTARGET"\n\npg0$V$ltrNav\n------FormBoundary\nContent-Disposition: form-data; name="__EVENTARGUMENT"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="___BrowserRefresh"\n\nbrowser refresh key\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlTerm"\n\n2022;FA\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlDept"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlCourseFrom"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlCourseTo"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlTitleRestrictor"\n\nBeginsWith\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$txtTitleRestrictor"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlCourseRestrictor"\n\nBeginsWith\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$txtCourseRestrictor"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlDivision"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlMethod"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlTimeFrom"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlTimeTo"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$days"\n\nrdAnyDay\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlFaculty"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlCampus"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlBuilding"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlSecStatus"\n\nOpenFull\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$txtMin"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$txtMax"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$hiddenCache"\n\nfalse\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$btnSearch"\n\nSearch\n------FormBoundary--
```

## Cookies 

Even if you don't log in, cookies can be used to store information about your behavior.  If a server sends a response with a `Set-Cookie:` header, it will be sent with every subsequent request on that same domain until it expires or you delete it.  This means that if you search for Computer Science courses and then Computer Information Systems courses, the server could "know" that someone searched for both terms because you'd be sending the same cookie that was unique to you each time.  Cookies can also be used to remove the need to log in with your username and password each time you visit a new page because it could set a cookie on your computer that identifies you.  As you visit different pages on the same site, your browser will send it back to the server.  But if you delete that cookie, you will need to log in again.  You can try this on the course search (without logging in):

**Response Header cookies**:
After visit and refresh:
![image](https://user-images.githubusercontent.com/9159008/183281649-b1a70bbd-fe6b-4479-9015-4fa803ab8c8f.png)

Check cookie and delete it (select it and hit the Delete key):
![image](https://user-images.githubusercontent.com/9159008/183281831-b5a87ea7-5d53-4e3e-a506-17192e6fd553.png)

Now new session cookie is generated:
![image](https://user-images.githubusercontent.com/9159008/183281952-97da7924-eec6-497a-9664-7b33539d2b72.png)

**Request Header cookies**
* The cookies that are set by the server in the response header are then sent back in the cookie request header:
![image](https://user-images.githubusercontent.com/9159008/183308852-bfd1bca8-10b7-40c3-9959-35bd3c628e90.png)

## POST method and body data

When you submit a form with a lot of information or sensitive information such as a username and password, you'll usually be making a POST request.  If you specify a GET method for the HTML of a form, the data will become part of the so-called query string in the URL, which is what appears after the question mark.  For example, if you have inputs named `username` and `password` and you submitted a form with a GET method to `https://www.mysite.com/login`, the request would look something like `https://www.mysite.com/login?username=foo&password=secret`.  The query string here would be `username=foo&password=secret`.  Clearly, the aforementioned URL would be bad to store in the browser history of a public computer as you wouldn't want to store usernames and passwords.  On the other hand, if you were doing a search, you might want to save the data as part of the URL.  So, it'd be reasonable to say have a GET request like `https://www.mysite.com/search?q=foo`, when a person makes a request to `https://www.mysite.com/search` and enters a query of `foo` in a text input named `q`.

When you do a course search on Lions Den, the POST method is used.  Although it might be useful to save the criteria from previous searches, this is not how it's done on Lions Den.  Also, a lot more data that you don't see is sent in hidden inputs, as you can tell by inspecting the payload of the response:  

![image](https://user-images.githubusercontent.com/9159008/183341020-eb22497b-cb7d-4789-8804-043a66e914ba.png)
and 
![image](https://user-images.githubusercontent.com/9159008/183340811-b9b868f8-ffe7-40ae-aeaa-a5a3600ffa9c.png)

In particular, this includes a **___BrowserRefresh** value needed for searches that could only be used once.  Therefore, even if you were able to make a GET request, you wouldn't be able to bookmark a previous search that you made as the __BrowserRefresh value would need to change.  One piece of data that's not needed and will need to be ommitted in our automated request is the hidden **__VIEWSTATE** input, which is very long and in this case most likely contains encrypted information about data that's been entered (https://docs.microsoft.com/en-us/previous-versions/aspnet/bb386448(v=vs.100)#background).  This is used to for example, if we search for 2022 Fall courses make sure that the term that's selected is 2022 Fall as well as save the values of hidden inputs.

![image](https://user-images.githubusercontent.com/9159008/183339948-4931a5c1-9016-4cb3-a3d9-3299b923b237.png)

Since we don't know how to change this encrypted value to say store the appropriate __BrowserRefresh value, which always changes, using a __VIEWSTATE from a previous search, if checked against our current search with a different __BrowserRefresh value, seems to cause the search to fail.

## High-level Web Scraping Strategy
 1. To perform our search, we will need to first get a valid ASP.NET SessionId cookie and the initial browser refresh key value we'll use to allow us to make a search so we will make a `GET` request to https://lionsden.molloy.edu/ICS/Course_Search/Course_Search.jnz?portlet=Course_Schedules&screen=Advanced+Course+Search&screenType=next to get these needed values.
 2. We will then make a POST request to make the search for all courses for the given semester with these values.
 3. We will use the text from the table headers to determine the structure of the course data table (e.g., which column represents the course code, the professor's name, etc.).
 4. We will get each course row of data, storing each cell in the appropriate property determined by the number of the column it appears in that row according to step 3.
 5. We will repeatedly extract the next browser refresh key from the HTML of the search results and use it to get the next page's search results.
