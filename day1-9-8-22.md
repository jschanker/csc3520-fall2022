# Course Data Scraping

Lions Den is an old system, and without direct access to the database from which it draws its information, our advising app will not be able to easily retrieve the course data.  As such, we'll want to create a bot that gets the relevant course data and stores all of it in a file in a format that's easily usable by our app.  The format we'll be using is called JSON (JavaScript Object Notation).  A bot that does this is called a web scraper.  To do this, we'll need to have it simulate the steps that a person would do: make a course search for all courses and manually retrieve the data for each course one page at a time.  The bot of course will accomplish this task a little differently than we would as it will not be using a mouse and a keyboard to navigate through the results and it will be working with source code rather than the output we see on the screen.  This means we will need to look "under the hood" to see the form data that's being sent and the HTML that's used for displaying the course information to determine how we program the bot.  

## Inspection of Requests and Responses
+ To determine the necessary request data (header and body), open up the Developer console first, make a search for courses at https://lionsden.molloy.edu/ICS/Course_Search/Course_Search.jnz?portlet=Course_Schedules&screen=Advanced+Course+Search&screenType=next and check the Network tab:
![image](https://user-images.githubusercontent.com/9159008/183238756-8840d8a2-812f-4c81-9156-efd5ff2d7110.png)
+ The relevant request is under `Course_Search.jnz?portlet=Course_Schedules&screen=Advanced+Course+Search&screenType=next`.
+ Trial and error by removing and modifying request data can tell you what's essential for it to succeed.  Using a tool such as Burp Suite Proxy allows you to modify and repeat the requests and see the response.  This way you can see those that provide the desired response data, which in this case will be the list of courses.  We'll spare you from this tedious work, and let you know what's needed:
  + **ASP.NET_SessionId Cookie**: When you first visit the site, the response will set this header to some "randomly generated number encoded into a 24-character string" (https://docs.microsoft.com/en-us/dotnet/api/system.web.sessionstate.sessionidmanager?view=netframework-4.8#remarks)
  + **Content-type header describing the format of the form data encoding**: `"content-type" : "multipart/form-data; boundary=----FormBoundary"` (https://stackoverflow.com/questions/3508338/what-is-the-boundary-in-multipart-form-data).
  + **method: "POST"**: This is the request method, which means there will be data in the body that's not part of the URL that's being requested.  The data in this case will be the encoded form data (https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)
  + **Value of hidden `___BrowserRefresh` form field**: There will be a new value each time we request a list of courses in a search or go through the pages in a search.  Using the same value twice gives you the following fun error message:
![image](https://user-images.githubusercontent.com/9159008/183279980-6c36a39d-8bd9-4a6f-a15b-a8d3dde4d4eb.png)
  + **Body data (Payload)**: Includes value of hidden `___BrowserRefresh` form field mentioned above: This will be a long string of names of fields and their values, separated by `----FormBoundary` indicated in the boundary of the `content-type` header and new lines (`\n`).  It'll be one long string that looks like the following (browser refresh key will be replaced with some value):
```
------FormBoundary\nContent-Disposition: form-data; name="__EVENTTARGET"\n\npg0$V$ltrNav\n------FormBoundary\nContent-Disposition: form-data; name="__EVENTARGUMENT"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="___BrowserRefresh"\n\nbrowser refresh key\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlTerm"\n\n2022;FA\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlDept"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlCourseFrom"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlCourseTo"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlTitleRestrictor"\n\nBeginsWith\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$txtTitleRestrictor"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlCourseRestrictor"\n\nBeginsWith\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$txtCourseRestrictor"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlDivision"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlMethod"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlTimeFrom"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlTimeTo"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$days"\n\nrdAnyDay\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlFaculty"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlCampus"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlBuilding"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlSecStatus"\n\nOpenFull\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$txtMin"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$txtMax"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$hiddenCache"\n\nfalse\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$btnSearch"\n\nSearch\n------FormBoundary--
```

## Cookies 

Even if you don't log in, cookies can be used to store information about your behavior.  If a server sends a response with a `Set-Cookie:` header, it will be sent with every subsequent request on that same domain until it expires or you delete it.  This means that if you search for Computer Science courses and then Computer Information Systems courses, the server could "know" that someone searched for both terms because you'd be sending the same cookie that was unique to you each time.  Cookies can also be used to remove the need to log in with your username and password each time you visit a new page because it could set a cookie on your computer that identifies you.  As you visit different pages on the same site, your browser will send it back to the server.  But if you delete that cookie, you will need to log in again.  You can try this on the course search (without logging in):

**Response Header cookies**:
After visit and refresh:
![image](https://user-images.githubusercontent.com/9159008/183281649-b1a70bbd-fe6b-4479-9015-4fa803ab8c8f.png)

Check cookie and delete it (select it and hit the Delete key):
![image](https://user-images.githubusercontent.com/9159008/183281831-b5a87ea7-5d53-4e3e-a506-17192e6fd553.png)

Now new session cookie is generated:
![image](https://user-images.githubusercontent.com/9159008/183281952-97da7924-eec6-497a-9664-7b33539d2b72.png)

**Request Header cookies**
* The cookies that are set by the server in the response header are then sent back in the cookie request header:
![image](https://user-images.githubusercontent.com/9159008/183308852-bfd1bca8-10b7-40c3-9959-35bd3c628e90.png)

## POST method and body data

When you submit a form with a lot of information or sensitive information such as a username and password, you'll usually be making a POST request.  If you specify a GET method for the HTML of a form, the data will become part of the so-called query string in the URL, which is what appears after the question mark.  For example, if you have inputs named `username` and `password` and you submitted a form with a GET method to `https://www.mysite.com/login`, the request would look something like `https://www.mysite.com/login?username=foo&password=secret`.  The query string here would be `username=foo&password=secret`.  Clearly, the aforementioned URL would be bad to store in the browser history of a public computer as you wouldn't want to store usernames and passwords.  On the other hand, if you were doing a search, you might want to save the data as part of the URL.  So, it'd be reasonable to say have a GET request like `https://www.mysite.com/search?q=foo`, when a person makes a request to `https://www.mysite.com/search` and enters a query of `foo` in a text input named `q`.

When you do a course search on Lions Den, the POST method is used.  Although it might be useful to save the criteria from previous searches, this is not how it's done on Lions Den.  Also, a lot more data that you don't see is sent in hidden inputs, as you can tell by inspecting the payload of the response:  

![image](https://user-images.githubusercontent.com/9159008/183341020-eb22497b-cb7d-4789-8804-043a66e914ba.png)
and 
![image](https://user-images.githubusercontent.com/9159008/183340811-b9b868f8-ffe7-40ae-aeaa-a5a3600ffa9c.png)

In particular, this includes a **___BrowserRefresh** value needed for searches that could only be used once.  Therefore, even if you were able to make a GET request, you wouldn't be able to bookmark a previous search that you made as the __BrowserRefresh value would need to change.  One piece of data that's not needed and will need to be ommitted in our automated request is the hidden **__VIEWSTATE** input, which is very long and in this case most likely contains encrypted information about data that's been entered (https://docs.microsoft.com/en-us/previous-versions/aspnet/bb386448(v=vs.100)#background).  This is used to for example, if we search for 2022 Fall courses make sure that the term that's selected is 2022 Fall as well as save the values of hidden inputs.

![image](https://user-images.githubusercontent.com/9159008/183339948-4931a5c1-9016-4cb3-a3d9-3299b923b237.png)

Since we don't know how to change this encrypted value to say store the appropriate __BrowserRefresh value, which always changes, using a __VIEWSTATE from a previous search, if checked against our current search with a different __BrowserRefresh value, seems to cause the search to fail.

## High-level Web Scraping Strategy
 1. To perform our search, we will need to first get a valid ASP.NET SessionId cookie and the initial browser refresh key value we'll use to allow us to make a search so we will make a `GET` request to https://lionsden.molloy.edu/ICS/Course_Search/Course_Search.jnz?portlet=Course_Schedules&screen=Advanced+Course+Search&screenType=next to get these needed values.
 2. We will then make a POST request to make the search for all courses for the given semester with these values.
 3. We will use the text from the table headers to determine the structure of the course data table (e.g., which column represents the course code, the professor's name, etc.).
 4. We will get each course row of data, storing each cell in the appropriate property determined by the number of the column it appears in that row according to step 3.
 5. We will repeatedly extract the next browser refresh key from the HTML of the search results and use it to get the next page's search results.

## Node Package Manager
First, you'll want to get an understanding of Node packages and modules.  Node packages allow you to make use of code that other people have written in your application.  For example, the [date-fns package](https://www.npmjs.com/package/date-fns) contains a function that allows you to get the number of years, months, hours, minutes, and seconds between two dates via the function [intervalToDuration](https://date-fns.org/v2.29.1/docs/intervalToDuration#examples).  NPM (Node Package Manager: https://www.tutorialspoint.com/nodejs/nodejs_npm.htm) maintains a searchable list of published packages that you can use in your code by including them in the package.json file.  Then you will be able to install them all by using `npm install` in the directory containing this file, or you can install individual packages like `date-fns` with `npm install date-fns`, which will add it to your package.json file.  If you create something useful that other people can use in their projects, you can even publish your own package on NPM!

You may hear the terms package and module used interchangably, but generally, a package will consist of a group of related modules (which might only be one) and that "is described by a `package.json` file."  A module is anything you can include with `require`.  See: https://stackoverflow.com/questions/20008442/difference-between-a-module-and-a-package-in-node-js and https://docs.npmjs.com/about-packages-and-modules).  `date-fns` can be considered a package or a module whose functionality can be used with `require('date-fns')`.  When you require it like that, you are usually getting all of the functionality, which will sometimes be present in the `index.__ file` of the repository or its `src` (source files) directory linked to on NPM (https://github.com/date-fns/date-fns/tree/main/src).  But packages like `date-fns` can be a directory and in that case you can include specific files if you don't need all of the functions it provides.  For example, you can use `require('date-fns/intervalToDuration')` if you only needed that function (https://github.com/date-fns/date-fns/tree/main/src/intervalToDuration).  For this particular example, it'll use the `index.ts` file of the `intervalToDuration` folder.  You can get some hands-on experience using package.json here: https://www.freecodecamp.org/learn/back-end-development-and-apis/#managing-packages-with-npm .

## Objects

In JavaScript, objects (See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects and https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics.) are a collection of key-value pairs called properties where the key is always a string, but the value can be anything. So for example, the following defines an object with the property keys `foo` and `bar` with the numerical value of `42` and a function that logs the sum of its two inputs, respectively.
```
const obj = {foo: 42, bar: (a, b) => console.log(a + b)};
```
If the key is something that can be a variable name, we can use dot notation to access the corresponding value. So, `obj.foo` will be `42`. Alternatively, we could use bracket notation, which is required when the key is not a valid variable name, e.g., something with a hyphen. We can also use it here, so `obj['foo']` would also be 42. Note that you need to use single or double quotes around the key as otherwise it'd look for the value of the variable `foo` when determining the key to use. To get the other value, you could use `obj.bar`, which would give you back a function. What do you think `obj.bar(1, 2)` would be? The value of an object property can even be another object itself in which case you can chaining to access the property values of property values:
```
const obj = {
  foo: {
    a: 42,
    b: {
      c: "bar"
    }
  }
};
console.log(foo.x); // logs 42
console.log(foo.b.c); // logs "bar"
```

## Getting started and the initial request to get the session cookie/browser refresh key
You can install `node` on your computer, but if you want to get to completing the tasks quickly, you can use `replit.com`.  If you haven't already, sign up for a GitHub account at https://www.github.com .  Then go to https://replit.com/languages/nodejs .  When asked to sign in, you can do so with your GitHub account.  After doing so, click the "Create Repl" button:
![image](https://user-images.githubusercontent.com/9159008/184059642-295906bd-7b53-4313-a622-b3aa4497e26b.png)

After doing so (perhaps first changing the title to something more memorable), you should see the following:

![image](https://user-images.githubusercontent.com/9159008/184059843-f67c4c13-1958-465d-b544-2b4f03619e48.png)

To get the needed information for this step, we will be using two node packages: [axios](https://www.npmjs.com/package/axios) to make the requests to LionsDen Course Search and get the response header with the session cookie and the response body HTML with the browser refresh key, and [Fast HTML Parser](https://www.npmjs.com/package/node-html-parser) (node-html-parser) to extract the browser refresh key from the HTML.  As noted earlier, you should user `require('module name')` and store the result in a variable, usually the same name, except removing `-` signs and using camel case instead.  In JavaScript, variable names can't have hyphens although they can have underscores (`_`).  If you go through the tutorials at https://www.freecodecamp.org/learn/back-end-development-and-apis/#managing-packages-with-npm , you'll see that you need to add these dependencies to the `package.json` file.  You can do this manually, or in Replit.com, you can click on the Packager icon: 

![image](https://user-images.githubusercontent.com/9159008/184060817-29b6d418-5c8f-4d68-89bc-651e2499696d.png)

And then search to install the packages you want.  Another option is to install each package using the command line with the command `npm install package name` (replacing package name with the desired one):

![image](https://user-images.githubusercontent.com/9159008/184061190-73935fa6-4ce8-4997-b636-e9b751e47235.png)

Once you install the packages, you'll want to make a `GET` request to the Lions Den course search (https://lionsden.molloy.edu/ICS/Course_Search/Course_Search.jnz?portlet=Course_Schedules&screen=Advanced+Course+Search&screenType=next).  You'll do this with `axios`.  Refer to the `async` example here: [https://axios-http.com/docs/example](https://axios-http.com/docs/example#:~:text=//%20Want%20to%20use%20async/await%3F%20Add%20the%20%60async%60%20keyword%20to%20your%20outer%20function/method.%0Aasync%20function%20getUser()%20%7B%0A%20%20try%20%7B%0A%20%20%20%20const%20response%20%3D%20await%20axios.get(%27/user%3FID%3D12345%27)%3B%0A%20%20%20%20console.log(response)%3B%0A%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20console.error(error)%3B%0A%20%20%7D%0A%7D), and modify it to see the response for the course search.  Call the function and click the green `Run` button to see the output.

```
// Want to use async/await? Add the `async` keyword to your outer function/method.
async function getUser() {
  try {
    const response = await axios.get('/user?ID=12345');
    console.log(response);
  } catch (error) {
    console.error(error);
  }
}
``` 

### `async/await`
In the code excerpt above, you'll notice an `async` and an `await`.  There are a lot of nuances here, but for now, think of `await` as saying "wait until I get the result from this until proceeding with later code in the **same function**."  If you want to use `await` in a function, that function needs to be prefixed with `async`.  You'll notice that the function itself does not have a `return` statement here.  If you wrote `return response` instead of `console.log(response)` and then tried using `console.log(getUser())` outside of the function, you would not see the response.  Instead, you would see a `Promise` with `<pending>`.

With `console.log(response)`:

![image](https://user-images.githubusercontent.com/9159008/184638326-29b9f1ba-b5ea-4338-9434-1371b1276e66.png)

With `return response`:

![image](https://user-images.githubusercontent.com/9159008/184639109-743f2732-bffd-4e99-a9be-c610aa164210.png)

This is because when you are declaring a `function` to be `async`, you are saying to the function I have other stuff to do so just ping me with your result when you're done and I'll do something with it when I'm ready. This is what it means for the code to run `asyn`chronously. The alternative is to run the function synchronously, which would mean that you would wait until the function is complete before proceeding. The reason you don't want to have to wait here is because when you send a request, it could be a little while before you get a response.  If you just stopped everything and waited, the web site would become unresponsive (e.g., clicking on something would have no effect.)  So, instead, when you call (run the code from) a function denoted `async`, you can leave the function and do other stuff while the function is paused waiting for the result from an `await`.

The mechanism for doing this is using something called `Promise`s, which is what will be returned from a function that's declared to be `async`. A `Promise` is an object that has a `then` and a `catch`, where you include functions for the what to do with the result after the function completes and what to do with an error if there were a problem.  In general, reading from/writing to files or making requests should be done asynchronously since they can be time-consuming operations, and as such when you use these functions, they `return` Promises.  There are however synchronous versions of functions for file reading and writing which just wait until completion, and for file reading, output the text of the file contents instead.

**NOTE**: Although it's prefixed with an `async`, the function will run synchronously until the first `await`.  To understand this a little better, consider the following and see if you can figure out what the output will be without running it:

```
async function foo() {
  console.log(1);
  const x = await (2 + 2);
  console.log(x);
  const y = await (x + 1);
  return y;
}
// Since foo is an async function, calling it like foo() gives back a Promise.
// As noted earlier a Promise has a `then`, which takes a function as an input
// and runs this function on successful completion with the return value as the input. 
foo().then((result) => console.log(result));
console.log(3);
```
### Extracting the session id cookie from the response header

Now let's modify our function that gets the course data response and logs it in steps:

1. First, have it `return` the `response` and instead of just calling the function, use `then` as we do in the above example to log the `result`.  Run your code and you should still see the response.
2. Next, modify the function to instead return the value of the `headers` property of the `response` object. If you did it correctly, the output should look something like this:

![image](https://user-images.githubusercontent.com/9159008/185532686-77e5b529-19f9-4703-bc5b-6ab0139a26aa.png)

3. Notice that the value of the `headers` property is also an object. Use chaining to instead return the value of the property containing the `ASP.NET_SessionId`, which will be an `Array`.   
4. Notice that all the `Array` items are strings with the name of the Cookie appearing before the `=` sign and the value appearing after it but before the semicolon. Use [find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find) and [startsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on the Array to get the string starting with `ASP.NET_SessionId=` (Don't assume this will be in the 0th location.) Return this instead of the entire `Array`.
5. Finally, use `substring` and `indexOf` on the result of step 4 to only `return` the value of the `ASP.NET_SessionId`, which starts after the `=` sign and before the `;`.  In this case, that will be `crccdaemcjv5hgpktvrnwlmz`.  Alternatively, you could get the `1`st item in the Array using `exec` (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec) with the appropriate regular expression, using a [capturing group](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet#:~:text=(x)-,Capturing%20group,-%3A%20Matches%20x):
    + **Hints if you want to use `exec`**: You want to get what appears between the = and ; so your regular expression should start with an = sign, end with a ;, and use capturing parentheses in between. In between the capturing parentheses, you're looking for one or more characters that don't include a ; so you'll want to use a [quantifier](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet#quantifiers) indicating one or more consecutive characters from a [negated of complemented character set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet#:~:text=A%20negated%20or%20complemented%20character%20class).

### Parsing the HTML and extracting the browser refresh key

If you inspect the source of https://lionsden.molloy.edu/ICS/Course_Search/Course_Search.jnz?portlet=Course_Schedules&screen=Advanced+Course+Search&screenType=next, you'll notice there's a hidden input with an id of `___BrowserRefresh`:

![image](https://user-images.githubusercontent.com/9159008/185769718-8c014fb0-04ff-4a60-a923-e4d138e0095f.png)

As mentioned earlier, we'll need to get its value, and we can use [Fast HTML Parser](https://www.npmjs.com/package/node-html-parser) (node-html-parser) to do this. This Node package allows you to construct a simplified DOM (Document Object Model) tree from the HTML source code and use methods to get elements and their attributes: 

<div align = "center">
<a title="‍Birger Eriksson, CC BY-SA 3.0 &lt;https://creativecommons.org/licenses/by-sa/3.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:DOM-model.svg"><img width="256" alt="DOM-model" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/DOM-model.svg/256px-DOM-model.svg.png"></a>
</div>
  
If you click on the above NPM link, you can see how to use the package. If you're interested in looking underneath the hood to see how this is done, there's also a link to the GitHub repository, but this won't be necessary if you just want to use it. So, now instead of `return`ing the session cookie as a string (text), we're going to modify our above function to `return` an `object` with keys of `sessionCookie` and `browserRefreshKey` and values of the session cookie from before and the browser refresh key we're going to show how to get now. Upon completion of this task, your modified output should look something like the following: 

![image](https://user-images.githubusercontent.com/9159008/185772199-17101d60-e032-4012-969d-b4f277a70263.png)

So here are the modifications to make:
1. First parse `response.data` using the `parse` method of the `nodeHTMLParser` object (https://www.npmjs.com/package/node-html-parser#user-content-parsedata-options), and store it in a variable, say `parseTree`.
2. Since we'll need to get the browser refresh key in another place as well, we're going to define a function to avoid some code duplication. So, the next step is to define a function named say `getBrowserRefreshKey` that takes a parse tree, also named say `parseTree`, as an input. This function will be an ordinary synchornous one, so do _not_ use `async`.  In this function, call [`getElementById`](https://www.npmjs.com/package/node-html-parser#user-content-nodegetelementbyidid-string-htmlelement) to get the element with the id of `___BrowserRefresh` and then call [`getAttribute`](https://www.npmjs.com/package/node-html-parser#htmlelementgetattributekey-string) on the result, passing the string literal `value` so we can get the value of this input (remember `value` needs to be put in single or double quotes here since you don't want to refer to a variable named `value`). You can use chaining here, which will look like something of the form `a.b().c(___)`. If you use an [arrow function expreession](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions) without the brackets (e.g., `const sum = (a, b) => a + b`), no `return` is needed.
3. Now go back to the orginal function. Instead of `return`ing the session id string, `return` an object literal with a key of `sessionCookie` and the value you were previously returning and a key of `browserRefreshKey` and the value of calling this `getBrowserRefreshKey` on `parseTree`.

If you did this correctly, then after running the code, you should see an output like above (with a different session cookie and browser refresh key). 

#### Function to get course data

Now that we have the browser refresh key and session cookie, we can make the needed POST request to get the first page of course data. To do this:
1. Define an `async` function, say `getCourseData`, that calls the function you defined before to get the session cookie and browser refresh key and stores it in a variable. Since the function is `async`, use `await` here. Since you're returning an object, you may want to look up [destructuring assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#syntax) which allows you to write one-liners to define multiple variables for each property.
2. Define a variable `bodyRequestData` whose value is in the above section (https://github.com/jschanker/csc3520-fall2022/edit/main/day1-9-8-22.md#inspection-of-requests-and-responses). Be sure to replace the `browserRefreshKey` to reference the variable that holds this value and remove the subject area CSC as we'll want to get the search results for every area. You might also want to replace `2022;FA` with a variable that holds this value, so it'll be easier to change in the future for other semesters. Look up [template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) to see a nice way to combine variable values and string literals without using string concatenation (`+`).
3. Now make a POST request using axios. This time you'll be using `axios.post` but will need to pass it an object with the relevant properties. `url` is the request url, `data` will be `bodyRequestData`, and you'll also need `headers` which itself will be an object with properties `"content-type" : "multipart/form-data; boundary=----FormBoundary"` (the format of the request body, boundary is the separator between names of inputs and their values) and a property with a key of `cookie` whose value is 'ASP.NET_SessionId=' followed by whatever the session id is. This time, you'll use another `await` for the `axios` call and store it in `response`.
4. Start by logging the `data` of response to see if it worked. (You'll of course need to call your new `getCourseData` function. If you get the same HTML as with the GET request something went wrong. Otherwise, if you can see some courses listed after a little time, it worked.
5. The next step is to parse the HTML as we did before to get the browser refresh key. Use the `parse` method of the `nodeHTMLParser` object as you did before.
6. The relevant data is in the table. Manually make a request for the course data and inspect the course table to see if it has a unique id, so you could use `getElementById` as before.  You can log its `innerHTML` property to see if you get the table of course data.
7. Next we'll want to get all of the table headings. This will make it so that we know which table cell corresponds to which piece of course data. This is important for making our scraper less fragile. For example, the third column might correspond to the course code now, but if columns are added or removed (as they have been in the past), it may not be that way in the future. To get all of the headings, you'll want to use `querySelectorAll` which will give you this data as an Array.
