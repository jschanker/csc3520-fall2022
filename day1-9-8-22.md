# Course Data Scraping

Lions Den is an old system, and without direct access to the database from which it draws its information, our advising app will not be able to easily retrieve the course data.  As such, we'll want to create a bot that gets the relevant course data and stores all of it in a file in a format that's easily usable by our app.  The format we'll be using is called JSON (JavaScript Object Notation).  A bot that does this is called a web scraper.  To do this, we'll need to have it simulate the steps that a person would do: make a course search for all courses and manually retrieve the data for each course one page at a time.  The bot of course will accomplish this task a little differently than we would as it will not be using a mouse and a keyboard to navigate through the results and it will be working with source code rather than the output we see on the screen.  This means we will need to look "under the hood" to see the form data that's being sent and the HTML that's used for displaying the course information to determine how we program the bot.  

## Inspection of Requests and Responses
+ To determine the necessary request data (header and body), open up the Developer console first, make a search for courses at https://lionsden.molloy.edu/ICS/Course_Search/Course_Search.jnz?portlet=Course_Schedules&screen=Advanced+Course+Search&screenType=next and check the Network tab:
![image](https://user-images.githubusercontent.com/9159008/183238756-8840d8a2-812f-4c81-9156-efd5ff2d7110.png)
+ The relevant request is under `Course_Search.jnz?portlet=Course_Schedules&screen=Advanced+Course+Search&screenType=next`.
+ Trial and error by removing and modifying request data can tell you what's essential for it to succeed.  Using a tool such as Burp Suite Proxy allows you to modify and repeat the requests and see the response.  This way you can see those that provide the desired response data, which in this case will be the list of courses.  We'll spare you from this tedious work, and let you know what's needed:
  + **ASP.NET_SessionId Cookie**: When you first visit the site, the response will set this header to some "randomly generated number encoded into a 24-character string" (https://docs.microsoft.com/en-us/dotnet/api/system.web.sessionstate.sessionidmanager?view=netframework-4.8#remarks)
  + **Content-type header describing the format of the form data encoding**: `"content-type" : "multipart/form-data; boundary=----FormBoundary"` (https://stackoverflow.com/questions/3508338/what-is-the-boundary-in-multipart-form-data).
  + **method: "POST"**: This is the request method, which means there will be data in the body that's not part of the URL that's being requested.  The data in this case will be the encoded form data (https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)
  + **Value of hidden `___BrowserRefresh` form field**: There will be a new value each time we request a list of courses in a search or go through the pages in a search.  Using the same value twice gives you the following fun error message:
![image](https://user-images.githubusercontent.com/9159008/183279980-6c36a39d-8bd9-4a6f-a15b-a8d3dde4d4eb.png)
  + **Body data (Payload)**: Includes value of hidden `___BrowserRefresh` form field mentioned above: This will be a long string of names of fields and their values, separated by `----FormBoundary` indicated in the boundary of the `content-type` header and new lines (`\n`).  It'll be one long string that looks like the following (browser refresh key will be replaced with some value):
```
------FormBoundary\nContent-Disposition: form-data; name="__EVENTTARGET"\n\npg0$V$ltrNav\n------FormBoundary\nContent-Disposition: form-data; name="__EVENTARGUMENT"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="___BrowserRefresh"\n\nbrowser refresh key\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlTerm"\n\n2022;FA\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlDept"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlCourseFrom"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlCourseTo"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlTitleRestrictor"\n\nBeginsWith\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$txtTitleRestrictor"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlCourseRestrictor"\n\nBeginsWith\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$txtCourseRestrictor"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlDivision"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlMethod"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlTimeFrom"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlTimeTo"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$days"\n\nrdAnyDay\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlFaculty"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlCampus"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlBuilding"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$ddlSecStatus"\n\nOpenFull\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$txtMin"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$txtMax"\n\n\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$hiddenCache"\n\nfalse\n------FormBoundary\nContent-Disposition: form-data; name="pg0$V$btnSearch"\n\nSearch\n------FormBoundary--
```

## Cookies 

Even if you don't log in, cookies can be used to store information about your behavior.  If a server sends a response with a `Set-Cookie:` header, it will be sent with every subsequent request on that same domain until it expires or you delete it.  This means that if you search for Computer Science courses and then Computer Information Systems courses, the server could "know" that someone searched for both terms because you'd be sending the same cookie that was unique to you each time.  Cookies can also be used to remove the need to log in with your username and password each time you visit a new page because it could set a cookie on your computer that identifies you.  As you visit different pages on the same site, your browser will send it back to the server.  But if you delete that cookie, you will need to log in again.  You can try this on the course search (without logging in):

**Response Header cookies**:
After visit and refresh:
![image](https://user-images.githubusercontent.com/9159008/183281649-b1a70bbd-fe6b-4479-9015-4fa803ab8c8f.png)

Check cookie and delete it (select it and hit the Delete key):
![image](https://user-images.githubusercontent.com/9159008/183281831-b5a87ea7-5d53-4e3e-a506-17192e6fd553.png)

Now new session cookie is generated:
![image](https://user-images.githubusercontent.com/9159008/183281952-97da7924-eec6-497a-9664-7b33539d2b72.png)

**Request Header cookies**
* The cookies that are set by the server in the response header are then sent back in the cookie request header:
![image](https://user-images.githubusercontent.com/9159008/183308852-bfd1bca8-10b7-40c3-9959-35bd3c628e90.png)

## POST method and body data

When you submit a form with a lot of information or sensitive information such as a username and password, you'll usually be making a POST request.  If you specify a GET method for the HTML of a form, the data will become part of the so-called query string in the URL, which is what appears after the question mark.  For example, if you have inputs named `username` and `password` and you submitted a form with a GET method to `https://www.mysite.com/login`, the request would look something like `https://www.mysite.com/login?username=foo&password=secret`.  The query string here would be `username=foo&password=secret`.  Clearly, the aforementioned URL would be bad to store in the browser history of a public computer as you wouldn't want to store usernames and passwords.  On the other hand, if you were doing a search, you might want to save the data as part of the URL.  So, it'd be reasonable to say have a GET request like `https://www.mysite.com/search?q=foo`, when a person makes a request to `https://www.mysite.com/search` and enters a query of `foo` in a text input named `q`.

When you do a course search on Lions Den, the POST method is used.  Although it might be useful to save the criteria from previous searches, this is not how it's done on Lions Den.  Also, a lot more data that you don't see is sent in hidden inputs, as you can tell by inspecting the payload of the response:  

![image](https://user-images.githubusercontent.com/9159008/183341020-eb22497b-cb7d-4789-8804-043a66e914ba.png)
and 
![image](https://user-images.githubusercontent.com/9159008/183340811-b9b868f8-ffe7-40ae-aeaa-a5a3600ffa9c.png)

In particular, this includes a **___BrowserRefresh** value needed for searches that could only be used once.  Therefore, even if you were able to make a GET request, you wouldn't be able to bookmark a previous search that you made as the __BrowserRefresh value would need to change.  One piece of data that's not needed and will need to be ommitted in our automated request is the hidden **__VIEWSTATE** input, which is very long and in this case most likely contains encrypted information about data that's been entered (https://docs.microsoft.com/en-us/previous-versions/aspnet/bb386448(v=vs.100)#background).  This is used to for example, if we search for 2022 Fall courses make sure that the term that's selected is 2022 Fall as well as save the values of hidden inputs.

![image](https://user-images.githubusercontent.com/9159008/183339948-4931a5c1-9016-4cb3-a3d9-3299b923b237.png)

Since we don't know how to change this encrypted value to say store the appropriate __BrowserRefresh value, which always changes, using a __VIEWSTATE from a previous search, if checked against our current search with a different __BrowserRefresh value, seems to cause the search to fail.

## High-level Web Scraping Strategy
 1. To perform our search, we will need to first get a valid ASP.NET SessionId cookie and the initial browser refresh key value we'll use to allow us to make a search so we will make a `GET` request to https://lionsden.molloy.edu/ICS/Course_Search/Course_Search.jnz?portlet=Course_Schedules&screen=Advanced+Course+Search&screenType=next to get these needed values.
 2. We will then make a POST request to make the search for all courses for the given semester with these values.
 3. We will use the text from the table headers to determine the structure of the course data table (e.g., which column represents the course code, the professor's name, etc.).
 4. We will get each course row of data, storing each cell in the appropriate property determined by the number of the column it appears in that row according to step 3.
 5. We will repeatedly extract the next browser refresh key from the HTML of the search results and use it to get the next page's search results.

## Node Package Manager
First, you'll want to get an understanding of Node packages and modules.  Node packages allow you to make use of code that other people have written in your application.  For example, the [date-fns package](https://www.npmjs.com/package/date-fns) contains a function that allows you to get the number of years, months, hours, minutes, and seconds between two dates via the function [intervalToDuration](https://date-fns.org/v2.29.1/docs/intervalToDuration#examples).  NPM (Node Package Manager: https://www.tutorialspoint.com/nodejs/nodejs_npm.htm) maintains a searchable list of published packages that you can use in your code by including them in the package.json file.  Then you will be able to install them all by using `npm install` in the directory containing this file, or you can install individual packages like `date-fns` with `npm install date-fns`, which will add it to your package.json file.  If you create something useful that other people can use in their projects, you can even publish your own package on NPM!

You may hear the terms package and module used interchangably, but generally, a package will consist of a group of related modules (which might only be one) and that "is described by a `package.json` file."  A module is anything you can include with `require`.  See: https://stackoverflow.com/questions/20008442/difference-between-a-module-and-a-package-in-node-js and https://docs.npmjs.com/about-packages-and-modules).  `date-fns` can be considered a package or a module whose functionality can be used with `require('date-fns')`.  When you require it like that, you are usually getting all of the functionality, which will sometimes be present in the `index.__ file` of the repository or its `src` (source files) directory linked to on NPM (https://github.com/date-fns/date-fns/tree/main/src).  But packages like `date-fns` can be a directory and in that case you can include specific files if you don't need all of the functions it provides.  For example, you can use `require('date-fns/intervalToDuration')` if you only needed that function (https://github.com/date-fns/date-fns/tree/main/src/intervalToDuration).  For this particular example, it'll use the `index.ts` file of the `intervalToDuration` folder.  You can get some hands-on experience using package.json here: https://www.freecodecamp.org/learn/back-end-development-and-apis/#managing-packages-with-npm .  

## Getting started and the initial request to get the session cookie/browser refresh key
You can install `node` on your computer, but if you want to get to completing the tasks quickly, you can use `replit.com`.  If you haven't already, sign up for a GitHub account at https://www.github.com .  Then go to https://replit.com/languages/nodejs .  When asked to sign in, you can do so with your GitHub account.  After doing so, click the "Create Repl" button:
![image](https://user-images.githubusercontent.com/9159008/184059642-295906bd-7b53-4313-a622-b3aa4497e26b.png)

After doing so (perhaps first changing the title to something more memorable), you should see the following:

![image](https://user-images.githubusercontent.com/9159008/184059843-f67c4c13-1958-465d-b544-2b4f03619e48.png)

To get the needed information for this step, we will be using two node packages: [axios](https://www.npmjs.com/package/axios) to make the requests to LionsDen Course Search and get the responses and [Fast HTML Parser](https://www.npmjs.com/package/node-html-parser) (node-html-parser).  As noted earlier, you should user `require('module name')` and store the result in a variable, usually the same name, except removing `-` signs and using camel case instead.  In JavaScript, variable names can't have hyphens although they can have underscores (`_`).  If you go through the tutorials at https://www.freecodecamp.org/learn/back-end-development-and-apis/#managing-packages-with-npm , you'll see that you need to add these dependencies to the `package.json` file.  You can do this manually, or in Replit.com, you can click on the Packager icon: 

![image](https://user-images.githubusercontent.com/9159008/184060817-29b6d418-5c8f-4d68-89bc-651e2499696d.png)

And then search to install the packages you want.  Another option is to install each package using the command line with the command `npm install package name` (replacing package name with the desired one):

![image](https://user-images.githubusercontent.com/9159008/184061190-73935fa6-4ce8-4997-b636-e9b751e47235.png)

Once you install the packages, you'll want to make a `GET` request to the Lions Den course search (https://lionsden.molloy.edu/ICS/Course_Search/Course_Search.jnz?portlet=Course_Schedules&screen=Advanced+Course+Search&screenType=next).  You'll do this with `axios`.  Refer to the `async` example here: https://axios-http.com/docs/example , and modify it to see the response for the course search.  Call the function and click the green `Run` button to see the output.
